// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dealing.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dealing_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dealing_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dealing_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dealing_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dealing_2eproto;
namespace protobuff_ser {
class Dealing;
struct DealingDefaultTypeInternal;
extern DealingDefaultTypeInternal _Dealing_default_instance_;
class ECP;
struct ECPDefaultTypeInternal;
extern ECPDefaultTypeInternal _ECP_default_instance_;
class NIZK;
struct NIZKDefaultTypeInternal;
extern NIZKDefaultTypeInternal _NIZK_default_instance_;
class QFI;
struct QFIDefaultTypeInternal;
extern QFIDefaultTypeInternal _QFI_default_instance_;
}  // namespace protobuff_ser
PROTOBUF_NAMESPACE_OPEN
template<> ::protobuff_ser::Dealing* Arena::CreateMaybeMessage<::protobuff_ser::Dealing>(Arena*);
template<> ::protobuff_ser::ECP* Arena::CreateMaybeMessage<::protobuff_ser::ECP>(Arena*);
template<> ::protobuff_ser::NIZK* Arena::CreateMaybeMessage<::protobuff_ser::NIZK>(Arena*);
template<> ::protobuff_ser::QFI* Arena::CreateMaybeMessage<::protobuff_ser::QFI>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace protobuff_ser {

// ===================================================================

class QFI final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuff_ser.QFI) */ {
 public:
  inline QFI() : QFI(nullptr) {}
  ~QFI() override;
  explicit PROTOBUF_CONSTEXPR QFI(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QFI(const QFI& from);
  QFI(QFI&& from) noexcept
    : QFI() {
    *this = ::std::move(from);
  }

  inline QFI& operator=(const QFI& from) {
    CopyFrom(from);
    return *this;
  }
  inline QFI& operator=(QFI&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QFI& default_instance() {
    return *internal_default_instance();
  }
  static inline const QFI* internal_default_instance() {
    return reinterpret_cast<const QFI*>(
               &_QFI_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(QFI& a, QFI& b) {
    a.Swap(&b);
  }
  inline void Swap(QFI* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QFI* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QFI* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QFI>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QFI& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QFI& from) {
    QFI::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QFI* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuff_ser.QFI";
  }
  protected:
  explicit QFI(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kApVecFieldNumber = 1,
    kGVecFieldNumber = 2,
    kTpVecFieldNumber = 3,
    kB0VecFieldNumber = 4,
    kIsNegFieldNumber = 5,
  };
  // bytes ap_vec = 1;
  void clear_ap_vec();
  const std::string& ap_vec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ap_vec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ap_vec();
  PROTOBUF_NODISCARD std::string* release_ap_vec();
  void set_allocated_ap_vec(std::string* ap_vec);
  private:
  const std::string& _internal_ap_vec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ap_vec(const std::string& value);
  std::string* _internal_mutable_ap_vec();
  public:

  // bytes g_vec = 2;
  void clear_g_vec();
  const std::string& g_vec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_g_vec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_g_vec();
  PROTOBUF_NODISCARD std::string* release_g_vec();
  void set_allocated_g_vec(std::string* g_vec);
  private:
  const std::string& _internal_g_vec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_g_vec(const std::string& value);
  std::string* _internal_mutable_g_vec();
  public:

  // bytes tp_vec = 3;
  void clear_tp_vec();
  const std::string& tp_vec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tp_vec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tp_vec();
  PROTOBUF_NODISCARD std::string* release_tp_vec();
  void set_allocated_tp_vec(std::string* tp_vec);
  private:
  const std::string& _internal_tp_vec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tp_vec(const std::string& value);
  std::string* _internal_mutable_tp_vec();
  public:

  // bytes b0_vec = 4;
  void clear_b0_vec();
  const std::string& b0_vec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_b0_vec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_b0_vec();
  PROTOBUF_NODISCARD std::string* release_b0_vec();
  void set_allocated_b0_vec(std::string* b0_vec);
  private:
  const std::string& _internal_b0_vec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_b0_vec(const std::string& value);
  std::string* _internal_mutable_b0_vec();
  public:

  // bool is_neg = 5;
  void clear_is_neg();
  bool is_neg() const;
  void set_is_neg(bool value);
  private:
  bool _internal_is_neg() const;
  void _internal_set_is_neg(bool value);
  public:

  // @@protoc_insertion_point(class_scope:protobuff_ser.QFI)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ap_vec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr g_vec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tp_vec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr b0_vec_;
    bool is_neg_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dealing_2eproto;
};
// -------------------------------------------------------------------

class ECP final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuff_ser.ECP) */ {
 public:
  inline ECP() : ECP(nullptr) {}
  ~ECP() override;
  explicit PROTOBUF_CONSTEXPR ECP(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ECP(const ECP& from);
  ECP(ECP&& from) noexcept
    : ECP() {
    *this = ::std::move(from);
  }

  inline ECP& operator=(const ECP& from) {
    CopyFrom(from);
    return *this;
  }
  inline ECP& operator=(ECP&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ECP& default_instance() {
    return *internal_default_instance();
  }
  static inline const ECP* internal_default_instance() {
    return reinterpret_cast<const ECP*>(
               &_ECP_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(ECP& a, ECP& b) {
    a.Swap(&b);
  }
  inline void Swap(ECP* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ECP* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ECP* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ECP>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ECP& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ECP& from) {
    ECP::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ECP* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuff_ser.ECP";
  }
  protected:
  explicit ECP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXVecFieldNumber = 1,
    kYVecFieldNumber = 2,
  };
  // bytes x_vec = 1;
  void clear_x_vec();
  const std::string& x_vec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_x_vec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_x_vec();
  PROTOBUF_NODISCARD std::string* release_x_vec();
  void set_allocated_x_vec(std::string* x_vec);
  private:
  const std::string& _internal_x_vec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_x_vec(const std::string& value);
  std::string* _internal_mutable_x_vec();
  public:

  // bytes y_vec = 2;
  void clear_y_vec();
  const std::string& y_vec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_y_vec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_y_vec();
  PROTOBUF_NODISCARD std::string* release_y_vec();
  void set_allocated_y_vec(std::string* y_vec);
  private:
  const std::string& _internal_y_vec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_y_vec(const std::string& value);
  std::string* _internal_mutable_y_vec();
  public:

  // @@protoc_insertion_point(class_scope:protobuff_ser.ECP)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr x_vec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr y_vec_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dealing_2eproto;
};
// -------------------------------------------------------------------

class NIZK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuff_ser.NIZK) */ {
 public:
  inline NIZK() : NIZK(nullptr) {}
  ~NIZK() override;
  explicit PROTOBUF_CONSTEXPR NIZK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NIZK(const NIZK& from);
  NIZK(NIZK&& from) noexcept
    : NIZK() {
    *this = ::std::move(from);
  }

  inline NIZK& operator=(const NIZK& from) {
    CopyFrom(from);
    return *this;
  }
  inline NIZK& operator=(NIZK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NIZK& default_instance() {
    return *internal_default_instance();
  }
  static inline const NIZK* internal_default_instance() {
    return reinterpret_cast<const NIZK*>(
               &_NIZK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(NIZK& a, NIZK& b) {
    a.Swap(&b);
  }
  inline void Swap(NIZK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NIZK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NIZK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NIZK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const NIZK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const NIZK& from) {
    NIZK::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NIZK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuff_ser.NIZK";
  }
  protected:
  explicit NIZK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZRVecFieldNumber = 4,
    kZAlphaVecFieldNumber = 5,
    kFfQfiFieldNumber = 1,
    kAaEcpFieldNumber = 2,
    kYyQfiFieldNumber = 3,
  };
  // bytes z_r_vec = 4;
  void clear_z_r_vec();
  const std::string& z_r_vec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z_r_vec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z_r_vec();
  PROTOBUF_NODISCARD std::string* release_z_r_vec();
  void set_allocated_z_r_vec(std::string* z_r_vec);
  private:
  const std::string& _internal_z_r_vec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z_r_vec(const std::string& value);
  std::string* _internal_mutable_z_r_vec();
  public:

  // bytes z_alpha_vec = 5;
  void clear_z_alpha_vec();
  const std::string& z_alpha_vec() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_z_alpha_vec(ArgT0&& arg0, ArgT... args);
  std::string* mutable_z_alpha_vec();
  PROTOBUF_NODISCARD std::string* release_z_alpha_vec();
  void set_allocated_z_alpha_vec(std::string* z_alpha_vec);
  private:
  const std::string& _internal_z_alpha_vec() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_z_alpha_vec(const std::string& value);
  std::string* _internal_mutable_z_alpha_vec();
  public:

  // .protobuff_ser.QFI ff_qfi = 1;
  bool has_ff_qfi() const;
  private:
  bool _internal_has_ff_qfi() const;
  public:
  void clear_ff_qfi();
  const ::protobuff_ser::QFI& ff_qfi() const;
  PROTOBUF_NODISCARD ::protobuff_ser::QFI* release_ff_qfi();
  ::protobuff_ser::QFI* mutable_ff_qfi();
  void set_allocated_ff_qfi(::protobuff_ser::QFI* ff_qfi);
  private:
  const ::protobuff_ser::QFI& _internal_ff_qfi() const;
  ::protobuff_ser::QFI* _internal_mutable_ff_qfi();
  public:
  void unsafe_arena_set_allocated_ff_qfi(
      ::protobuff_ser::QFI* ff_qfi);
  ::protobuff_ser::QFI* unsafe_arena_release_ff_qfi();

  // .protobuff_ser.ECP aa_ecp = 2;
  bool has_aa_ecp() const;
  private:
  bool _internal_has_aa_ecp() const;
  public:
  void clear_aa_ecp();
  const ::protobuff_ser::ECP& aa_ecp() const;
  PROTOBUF_NODISCARD ::protobuff_ser::ECP* release_aa_ecp();
  ::protobuff_ser::ECP* mutable_aa_ecp();
  void set_allocated_aa_ecp(::protobuff_ser::ECP* aa_ecp);
  private:
  const ::protobuff_ser::ECP& _internal_aa_ecp() const;
  ::protobuff_ser::ECP* _internal_mutable_aa_ecp();
  public:
  void unsafe_arena_set_allocated_aa_ecp(
      ::protobuff_ser::ECP* aa_ecp);
  ::protobuff_ser::ECP* unsafe_arena_release_aa_ecp();

  // .protobuff_ser.QFI yy_qfi = 3;
  bool has_yy_qfi() const;
  private:
  bool _internal_has_yy_qfi() const;
  public:
  void clear_yy_qfi();
  const ::protobuff_ser::QFI& yy_qfi() const;
  PROTOBUF_NODISCARD ::protobuff_ser::QFI* release_yy_qfi();
  ::protobuff_ser::QFI* mutable_yy_qfi();
  void set_allocated_yy_qfi(::protobuff_ser::QFI* yy_qfi);
  private:
  const ::protobuff_ser::QFI& _internal_yy_qfi() const;
  ::protobuff_ser::QFI* _internal_mutable_yy_qfi();
  public:
  void unsafe_arena_set_allocated_yy_qfi(
      ::protobuff_ser::QFI* yy_qfi);
  ::protobuff_ser::QFI* unsafe_arena_release_yy_qfi();

  // @@protoc_insertion_point(class_scope:protobuff_ser.NIZK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_r_vec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr z_alpha_vec_;
    ::protobuff_ser::QFI* ff_qfi_;
    ::protobuff_ser::ECP* aa_ecp_;
    ::protobuff_ser::QFI* yy_qfi_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dealing_2eproto;
};
// -------------------------------------------------------------------

class Dealing final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:protobuff_ser.Dealing) */ {
 public:
  inline Dealing() : Dealing(nullptr) {}
  ~Dealing() override;
  explicit PROTOBUF_CONSTEXPR Dealing(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Dealing(const Dealing& from);
  Dealing(Dealing&& from) noexcept
    : Dealing() {
    *this = ::std::move(from);
  }

  inline Dealing& operator=(const Dealing& from) {
    CopyFrom(from);
    return *this;
  }
  inline Dealing& operator=(Dealing&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Dealing& default_instance() {
    return *internal_default_instance();
  }
  static inline const Dealing* internal_default_instance() {
    return reinterpret_cast<const Dealing*>(
               &_Dealing_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Dealing& a, Dealing& b) {
    a.Swap(&b);
  }
  inline void Swap(Dealing* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Dealing* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Dealing* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Dealing>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Dealing& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Dealing& from) {
    Dealing::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Dealing* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "protobuff_ser.Dealing";
  }
  protected:
  explicit Dealing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCiphertextsFieldNumber = 1,
    kPublicCoefficientsFieldNumber = 3,
    kGRFieldNumber = 2,
    kNizkShareFieldNumber = 4,
  };
  // repeated .protobuff_ser.QFI ciphertexts = 1;
  int ciphertexts_size() const;
  private:
  int _internal_ciphertexts_size() const;
  public:
  void clear_ciphertexts();
  ::protobuff_ser::QFI* mutable_ciphertexts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::QFI >*
      mutable_ciphertexts();
  private:
  const ::protobuff_ser::QFI& _internal_ciphertexts(int index) const;
  ::protobuff_ser::QFI* _internal_add_ciphertexts();
  public:
  const ::protobuff_ser::QFI& ciphertexts(int index) const;
  ::protobuff_ser::QFI* add_ciphertexts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::QFI >&
      ciphertexts() const;

  // repeated .protobuff_ser.ECP public_coefficients = 3;
  int public_coefficients_size() const;
  private:
  int _internal_public_coefficients_size() const;
  public:
  void clear_public_coefficients();
  ::protobuff_ser::ECP* mutable_public_coefficients(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::ECP >*
      mutable_public_coefficients();
  private:
  const ::protobuff_ser::ECP& _internal_public_coefficients(int index) const;
  ::protobuff_ser::ECP* _internal_add_public_coefficients();
  public:
  const ::protobuff_ser::ECP& public_coefficients(int index) const;
  ::protobuff_ser::ECP* add_public_coefficients();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::ECP >&
      public_coefficients() const;

  // .protobuff_ser.QFI g_r = 2;
  bool has_g_r() const;
  private:
  bool _internal_has_g_r() const;
  public:
  void clear_g_r();
  const ::protobuff_ser::QFI& g_r() const;
  PROTOBUF_NODISCARD ::protobuff_ser::QFI* release_g_r();
  ::protobuff_ser::QFI* mutable_g_r();
  void set_allocated_g_r(::protobuff_ser::QFI* g_r);
  private:
  const ::protobuff_ser::QFI& _internal_g_r() const;
  ::protobuff_ser::QFI* _internal_mutable_g_r();
  public:
  void unsafe_arena_set_allocated_g_r(
      ::protobuff_ser::QFI* g_r);
  ::protobuff_ser::QFI* unsafe_arena_release_g_r();

  // .protobuff_ser.NIZK nizk_share = 4;
  bool has_nizk_share() const;
  private:
  bool _internal_has_nizk_share() const;
  public:
  void clear_nizk_share();
  const ::protobuff_ser::NIZK& nizk_share() const;
  PROTOBUF_NODISCARD ::protobuff_ser::NIZK* release_nizk_share();
  ::protobuff_ser::NIZK* mutable_nizk_share();
  void set_allocated_nizk_share(::protobuff_ser::NIZK* nizk_share);
  private:
  const ::protobuff_ser::NIZK& _internal_nizk_share() const;
  ::protobuff_ser::NIZK* _internal_mutable_nizk_share();
  public:
  void unsafe_arena_set_allocated_nizk_share(
      ::protobuff_ser::NIZK* nizk_share);
  ::protobuff_ser::NIZK* unsafe_arena_release_nizk_share();

  // @@protoc_insertion_point(class_scope:protobuff_ser.Dealing)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::QFI > ciphertexts_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::ECP > public_coefficients_;
    ::protobuff_ser::QFI* g_r_;
    ::protobuff_ser::NIZK* nizk_share_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_dealing_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// QFI

// bytes ap_vec = 1;
inline void QFI::clear_ap_vec() {
  _impl_.ap_vec_.ClearToEmpty();
}
inline const std::string& QFI::ap_vec() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.QFI.ap_vec)
  return _internal_ap_vec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QFI::set_ap_vec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.ap_vec_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuff_ser.QFI.ap_vec)
}
inline std::string* QFI::mutable_ap_vec() {
  std::string* _s = _internal_mutable_ap_vec();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.QFI.ap_vec)
  return _s;
}
inline const std::string& QFI::_internal_ap_vec() const {
  return _impl_.ap_vec_.Get();
}
inline void QFI::_internal_set_ap_vec(const std::string& value) {
  
  _impl_.ap_vec_.Set(value, GetArenaForAllocation());
}
inline std::string* QFI::_internal_mutable_ap_vec() {
  
  return _impl_.ap_vec_.Mutable(GetArenaForAllocation());
}
inline std::string* QFI::release_ap_vec() {
  // @@protoc_insertion_point(field_release:protobuff_ser.QFI.ap_vec)
  return _impl_.ap_vec_.Release();
}
inline void QFI::set_allocated_ap_vec(std::string* ap_vec) {
  if (ap_vec != nullptr) {
    
  } else {
    
  }
  _impl_.ap_vec_.SetAllocated(ap_vec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.ap_vec_.IsDefault()) {
    _impl_.ap_vec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.QFI.ap_vec)
}

// bytes g_vec = 2;
inline void QFI::clear_g_vec() {
  _impl_.g_vec_.ClearToEmpty();
}
inline const std::string& QFI::g_vec() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.QFI.g_vec)
  return _internal_g_vec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QFI::set_g_vec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.g_vec_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuff_ser.QFI.g_vec)
}
inline std::string* QFI::mutable_g_vec() {
  std::string* _s = _internal_mutable_g_vec();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.QFI.g_vec)
  return _s;
}
inline const std::string& QFI::_internal_g_vec() const {
  return _impl_.g_vec_.Get();
}
inline void QFI::_internal_set_g_vec(const std::string& value) {
  
  _impl_.g_vec_.Set(value, GetArenaForAllocation());
}
inline std::string* QFI::_internal_mutable_g_vec() {
  
  return _impl_.g_vec_.Mutable(GetArenaForAllocation());
}
inline std::string* QFI::release_g_vec() {
  // @@protoc_insertion_point(field_release:protobuff_ser.QFI.g_vec)
  return _impl_.g_vec_.Release();
}
inline void QFI::set_allocated_g_vec(std::string* g_vec) {
  if (g_vec != nullptr) {
    
  } else {
    
  }
  _impl_.g_vec_.SetAllocated(g_vec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.g_vec_.IsDefault()) {
    _impl_.g_vec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.QFI.g_vec)
}

// bytes tp_vec = 3;
inline void QFI::clear_tp_vec() {
  _impl_.tp_vec_.ClearToEmpty();
}
inline const std::string& QFI::tp_vec() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.QFI.tp_vec)
  return _internal_tp_vec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QFI::set_tp_vec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.tp_vec_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuff_ser.QFI.tp_vec)
}
inline std::string* QFI::mutable_tp_vec() {
  std::string* _s = _internal_mutable_tp_vec();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.QFI.tp_vec)
  return _s;
}
inline const std::string& QFI::_internal_tp_vec() const {
  return _impl_.tp_vec_.Get();
}
inline void QFI::_internal_set_tp_vec(const std::string& value) {
  
  _impl_.tp_vec_.Set(value, GetArenaForAllocation());
}
inline std::string* QFI::_internal_mutable_tp_vec() {
  
  return _impl_.tp_vec_.Mutable(GetArenaForAllocation());
}
inline std::string* QFI::release_tp_vec() {
  // @@protoc_insertion_point(field_release:protobuff_ser.QFI.tp_vec)
  return _impl_.tp_vec_.Release();
}
inline void QFI::set_allocated_tp_vec(std::string* tp_vec) {
  if (tp_vec != nullptr) {
    
  } else {
    
  }
  _impl_.tp_vec_.SetAllocated(tp_vec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.tp_vec_.IsDefault()) {
    _impl_.tp_vec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.QFI.tp_vec)
}

// bytes b0_vec = 4;
inline void QFI::clear_b0_vec() {
  _impl_.b0_vec_.ClearToEmpty();
}
inline const std::string& QFI::b0_vec() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.QFI.b0_vec)
  return _internal_b0_vec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void QFI::set_b0_vec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.b0_vec_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuff_ser.QFI.b0_vec)
}
inline std::string* QFI::mutable_b0_vec() {
  std::string* _s = _internal_mutable_b0_vec();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.QFI.b0_vec)
  return _s;
}
inline const std::string& QFI::_internal_b0_vec() const {
  return _impl_.b0_vec_.Get();
}
inline void QFI::_internal_set_b0_vec(const std::string& value) {
  
  _impl_.b0_vec_.Set(value, GetArenaForAllocation());
}
inline std::string* QFI::_internal_mutable_b0_vec() {
  
  return _impl_.b0_vec_.Mutable(GetArenaForAllocation());
}
inline std::string* QFI::release_b0_vec() {
  // @@protoc_insertion_point(field_release:protobuff_ser.QFI.b0_vec)
  return _impl_.b0_vec_.Release();
}
inline void QFI::set_allocated_b0_vec(std::string* b0_vec) {
  if (b0_vec != nullptr) {
    
  } else {
    
  }
  _impl_.b0_vec_.SetAllocated(b0_vec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.b0_vec_.IsDefault()) {
    _impl_.b0_vec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.QFI.b0_vec)
}

// bool is_neg = 5;
inline void QFI::clear_is_neg() {
  _impl_.is_neg_ = false;
}
inline bool QFI::_internal_is_neg() const {
  return _impl_.is_neg_;
}
inline bool QFI::is_neg() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.QFI.is_neg)
  return _internal_is_neg();
}
inline void QFI::_internal_set_is_neg(bool value) {
  
  _impl_.is_neg_ = value;
}
inline void QFI::set_is_neg(bool value) {
  _internal_set_is_neg(value);
  // @@protoc_insertion_point(field_set:protobuff_ser.QFI.is_neg)
}

// -------------------------------------------------------------------

// ECP

// bytes x_vec = 1;
inline void ECP::clear_x_vec() {
  _impl_.x_vec_.ClearToEmpty();
}
inline const std::string& ECP::x_vec() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.ECP.x_vec)
  return _internal_x_vec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ECP::set_x_vec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.x_vec_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuff_ser.ECP.x_vec)
}
inline std::string* ECP::mutable_x_vec() {
  std::string* _s = _internal_mutable_x_vec();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.ECP.x_vec)
  return _s;
}
inline const std::string& ECP::_internal_x_vec() const {
  return _impl_.x_vec_.Get();
}
inline void ECP::_internal_set_x_vec(const std::string& value) {
  
  _impl_.x_vec_.Set(value, GetArenaForAllocation());
}
inline std::string* ECP::_internal_mutable_x_vec() {
  
  return _impl_.x_vec_.Mutable(GetArenaForAllocation());
}
inline std::string* ECP::release_x_vec() {
  // @@protoc_insertion_point(field_release:protobuff_ser.ECP.x_vec)
  return _impl_.x_vec_.Release();
}
inline void ECP::set_allocated_x_vec(std::string* x_vec) {
  if (x_vec != nullptr) {
    
  } else {
    
  }
  _impl_.x_vec_.SetAllocated(x_vec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.x_vec_.IsDefault()) {
    _impl_.x_vec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.ECP.x_vec)
}

// bytes y_vec = 2;
inline void ECP::clear_y_vec() {
  _impl_.y_vec_.ClearToEmpty();
}
inline const std::string& ECP::y_vec() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.ECP.y_vec)
  return _internal_y_vec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ECP::set_y_vec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.y_vec_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuff_ser.ECP.y_vec)
}
inline std::string* ECP::mutable_y_vec() {
  std::string* _s = _internal_mutable_y_vec();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.ECP.y_vec)
  return _s;
}
inline const std::string& ECP::_internal_y_vec() const {
  return _impl_.y_vec_.Get();
}
inline void ECP::_internal_set_y_vec(const std::string& value) {
  
  _impl_.y_vec_.Set(value, GetArenaForAllocation());
}
inline std::string* ECP::_internal_mutable_y_vec() {
  
  return _impl_.y_vec_.Mutable(GetArenaForAllocation());
}
inline std::string* ECP::release_y_vec() {
  // @@protoc_insertion_point(field_release:protobuff_ser.ECP.y_vec)
  return _impl_.y_vec_.Release();
}
inline void ECP::set_allocated_y_vec(std::string* y_vec) {
  if (y_vec != nullptr) {
    
  } else {
    
  }
  _impl_.y_vec_.SetAllocated(y_vec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.y_vec_.IsDefault()) {
    _impl_.y_vec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.ECP.y_vec)
}

// -------------------------------------------------------------------

// NIZK

// .protobuff_ser.QFI ff_qfi = 1;
inline bool NIZK::_internal_has_ff_qfi() const {
  return this != internal_default_instance() && _impl_.ff_qfi_ != nullptr;
}
inline bool NIZK::has_ff_qfi() const {
  return _internal_has_ff_qfi();
}
inline void NIZK::clear_ff_qfi() {
  if (GetArenaForAllocation() == nullptr && _impl_.ff_qfi_ != nullptr) {
    delete _impl_.ff_qfi_;
  }
  _impl_.ff_qfi_ = nullptr;
}
inline const ::protobuff_ser::QFI& NIZK::_internal_ff_qfi() const {
  const ::protobuff_ser::QFI* p = _impl_.ff_qfi_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuff_ser::QFI&>(
      ::protobuff_ser::_QFI_default_instance_);
}
inline const ::protobuff_ser::QFI& NIZK::ff_qfi() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.NIZK.ff_qfi)
  return _internal_ff_qfi();
}
inline void NIZK::unsafe_arena_set_allocated_ff_qfi(
    ::protobuff_ser::QFI* ff_qfi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ff_qfi_);
  }
  _impl_.ff_qfi_ = ff_qfi;
  if (ff_qfi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuff_ser.NIZK.ff_qfi)
}
inline ::protobuff_ser::QFI* NIZK::release_ff_qfi() {
  
  ::protobuff_ser::QFI* temp = _impl_.ff_qfi_;
  _impl_.ff_qfi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protobuff_ser::QFI* NIZK::unsafe_arena_release_ff_qfi() {
  // @@protoc_insertion_point(field_release:protobuff_ser.NIZK.ff_qfi)
  
  ::protobuff_ser::QFI* temp = _impl_.ff_qfi_;
  _impl_.ff_qfi_ = nullptr;
  return temp;
}
inline ::protobuff_ser::QFI* NIZK::_internal_mutable_ff_qfi() {
  
  if (_impl_.ff_qfi_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuff_ser::QFI>(GetArenaForAllocation());
    _impl_.ff_qfi_ = p;
  }
  return _impl_.ff_qfi_;
}
inline ::protobuff_ser::QFI* NIZK::mutable_ff_qfi() {
  ::protobuff_ser::QFI* _msg = _internal_mutable_ff_qfi();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.NIZK.ff_qfi)
  return _msg;
}
inline void NIZK::set_allocated_ff_qfi(::protobuff_ser::QFI* ff_qfi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ff_qfi_;
  }
  if (ff_qfi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ff_qfi);
    if (message_arena != submessage_arena) {
      ff_qfi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ff_qfi, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.ff_qfi_ = ff_qfi;
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.NIZK.ff_qfi)
}

// .protobuff_ser.ECP aa_ecp = 2;
inline bool NIZK::_internal_has_aa_ecp() const {
  return this != internal_default_instance() && _impl_.aa_ecp_ != nullptr;
}
inline bool NIZK::has_aa_ecp() const {
  return _internal_has_aa_ecp();
}
inline void NIZK::clear_aa_ecp() {
  if (GetArenaForAllocation() == nullptr && _impl_.aa_ecp_ != nullptr) {
    delete _impl_.aa_ecp_;
  }
  _impl_.aa_ecp_ = nullptr;
}
inline const ::protobuff_ser::ECP& NIZK::_internal_aa_ecp() const {
  const ::protobuff_ser::ECP* p = _impl_.aa_ecp_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuff_ser::ECP&>(
      ::protobuff_ser::_ECP_default_instance_);
}
inline const ::protobuff_ser::ECP& NIZK::aa_ecp() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.NIZK.aa_ecp)
  return _internal_aa_ecp();
}
inline void NIZK::unsafe_arena_set_allocated_aa_ecp(
    ::protobuff_ser::ECP* aa_ecp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.aa_ecp_);
  }
  _impl_.aa_ecp_ = aa_ecp;
  if (aa_ecp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuff_ser.NIZK.aa_ecp)
}
inline ::protobuff_ser::ECP* NIZK::release_aa_ecp() {
  
  ::protobuff_ser::ECP* temp = _impl_.aa_ecp_;
  _impl_.aa_ecp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protobuff_ser::ECP* NIZK::unsafe_arena_release_aa_ecp() {
  // @@protoc_insertion_point(field_release:protobuff_ser.NIZK.aa_ecp)
  
  ::protobuff_ser::ECP* temp = _impl_.aa_ecp_;
  _impl_.aa_ecp_ = nullptr;
  return temp;
}
inline ::protobuff_ser::ECP* NIZK::_internal_mutable_aa_ecp() {
  
  if (_impl_.aa_ecp_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuff_ser::ECP>(GetArenaForAllocation());
    _impl_.aa_ecp_ = p;
  }
  return _impl_.aa_ecp_;
}
inline ::protobuff_ser::ECP* NIZK::mutable_aa_ecp() {
  ::protobuff_ser::ECP* _msg = _internal_mutable_aa_ecp();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.NIZK.aa_ecp)
  return _msg;
}
inline void NIZK::set_allocated_aa_ecp(::protobuff_ser::ECP* aa_ecp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.aa_ecp_;
  }
  if (aa_ecp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(aa_ecp);
    if (message_arena != submessage_arena) {
      aa_ecp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, aa_ecp, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.aa_ecp_ = aa_ecp;
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.NIZK.aa_ecp)
}

// .protobuff_ser.QFI yy_qfi = 3;
inline bool NIZK::_internal_has_yy_qfi() const {
  return this != internal_default_instance() && _impl_.yy_qfi_ != nullptr;
}
inline bool NIZK::has_yy_qfi() const {
  return _internal_has_yy_qfi();
}
inline void NIZK::clear_yy_qfi() {
  if (GetArenaForAllocation() == nullptr && _impl_.yy_qfi_ != nullptr) {
    delete _impl_.yy_qfi_;
  }
  _impl_.yy_qfi_ = nullptr;
}
inline const ::protobuff_ser::QFI& NIZK::_internal_yy_qfi() const {
  const ::protobuff_ser::QFI* p = _impl_.yy_qfi_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuff_ser::QFI&>(
      ::protobuff_ser::_QFI_default_instance_);
}
inline const ::protobuff_ser::QFI& NIZK::yy_qfi() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.NIZK.yy_qfi)
  return _internal_yy_qfi();
}
inline void NIZK::unsafe_arena_set_allocated_yy_qfi(
    ::protobuff_ser::QFI* yy_qfi) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.yy_qfi_);
  }
  _impl_.yy_qfi_ = yy_qfi;
  if (yy_qfi) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuff_ser.NIZK.yy_qfi)
}
inline ::protobuff_ser::QFI* NIZK::release_yy_qfi() {
  
  ::protobuff_ser::QFI* temp = _impl_.yy_qfi_;
  _impl_.yy_qfi_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protobuff_ser::QFI* NIZK::unsafe_arena_release_yy_qfi() {
  // @@protoc_insertion_point(field_release:protobuff_ser.NIZK.yy_qfi)
  
  ::protobuff_ser::QFI* temp = _impl_.yy_qfi_;
  _impl_.yy_qfi_ = nullptr;
  return temp;
}
inline ::protobuff_ser::QFI* NIZK::_internal_mutable_yy_qfi() {
  
  if (_impl_.yy_qfi_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuff_ser::QFI>(GetArenaForAllocation());
    _impl_.yy_qfi_ = p;
  }
  return _impl_.yy_qfi_;
}
inline ::protobuff_ser::QFI* NIZK::mutable_yy_qfi() {
  ::protobuff_ser::QFI* _msg = _internal_mutable_yy_qfi();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.NIZK.yy_qfi)
  return _msg;
}
inline void NIZK::set_allocated_yy_qfi(::protobuff_ser::QFI* yy_qfi) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.yy_qfi_;
  }
  if (yy_qfi) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(yy_qfi);
    if (message_arena != submessage_arena) {
      yy_qfi = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, yy_qfi, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.yy_qfi_ = yy_qfi;
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.NIZK.yy_qfi)
}

// bytes z_r_vec = 4;
inline void NIZK::clear_z_r_vec() {
  _impl_.z_r_vec_.ClearToEmpty();
}
inline const std::string& NIZK::z_r_vec() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.NIZK.z_r_vec)
  return _internal_z_r_vec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NIZK::set_z_r_vec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.z_r_vec_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuff_ser.NIZK.z_r_vec)
}
inline std::string* NIZK::mutable_z_r_vec() {
  std::string* _s = _internal_mutable_z_r_vec();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.NIZK.z_r_vec)
  return _s;
}
inline const std::string& NIZK::_internal_z_r_vec() const {
  return _impl_.z_r_vec_.Get();
}
inline void NIZK::_internal_set_z_r_vec(const std::string& value) {
  
  _impl_.z_r_vec_.Set(value, GetArenaForAllocation());
}
inline std::string* NIZK::_internal_mutable_z_r_vec() {
  
  return _impl_.z_r_vec_.Mutable(GetArenaForAllocation());
}
inline std::string* NIZK::release_z_r_vec() {
  // @@protoc_insertion_point(field_release:protobuff_ser.NIZK.z_r_vec)
  return _impl_.z_r_vec_.Release();
}
inline void NIZK::set_allocated_z_r_vec(std::string* z_r_vec) {
  if (z_r_vec != nullptr) {
    
  } else {
    
  }
  _impl_.z_r_vec_.SetAllocated(z_r_vec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.z_r_vec_.IsDefault()) {
    _impl_.z_r_vec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.NIZK.z_r_vec)
}

// bytes z_alpha_vec = 5;
inline void NIZK::clear_z_alpha_vec() {
  _impl_.z_alpha_vec_.ClearToEmpty();
}
inline const std::string& NIZK::z_alpha_vec() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.NIZK.z_alpha_vec)
  return _internal_z_alpha_vec();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NIZK::set_z_alpha_vec(ArgT0&& arg0, ArgT... args) {
 
 _impl_.z_alpha_vec_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:protobuff_ser.NIZK.z_alpha_vec)
}
inline std::string* NIZK::mutable_z_alpha_vec() {
  std::string* _s = _internal_mutable_z_alpha_vec();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.NIZK.z_alpha_vec)
  return _s;
}
inline const std::string& NIZK::_internal_z_alpha_vec() const {
  return _impl_.z_alpha_vec_.Get();
}
inline void NIZK::_internal_set_z_alpha_vec(const std::string& value) {
  
  _impl_.z_alpha_vec_.Set(value, GetArenaForAllocation());
}
inline std::string* NIZK::_internal_mutable_z_alpha_vec() {
  
  return _impl_.z_alpha_vec_.Mutable(GetArenaForAllocation());
}
inline std::string* NIZK::release_z_alpha_vec() {
  // @@protoc_insertion_point(field_release:protobuff_ser.NIZK.z_alpha_vec)
  return _impl_.z_alpha_vec_.Release();
}
inline void NIZK::set_allocated_z_alpha_vec(std::string* z_alpha_vec) {
  if (z_alpha_vec != nullptr) {
    
  } else {
    
  }
  _impl_.z_alpha_vec_.SetAllocated(z_alpha_vec, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.z_alpha_vec_.IsDefault()) {
    _impl_.z_alpha_vec_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.NIZK.z_alpha_vec)
}

// -------------------------------------------------------------------

// Dealing

// repeated .protobuff_ser.QFI ciphertexts = 1;
inline int Dealing::_internal_ciphertexts_size() const {
  return _impl_.ciphertexts_.size();
}
inline int Dealing::ciphertexts_size() const {
  return _internal_ciphertexts_size();
}
inline void Dealing::clear_ciphertexts() {
  _impl_.ciphertexts_.Clear();
}
inline ::protobuff_ser::QFI* Dealing::mutable_ciphertexts(int index) {
  // @@protoc_insertion_point(field_mutable:protobuff_ser.Dealing.ciphertexts)
  return _impl_.ciphertexts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::QFI >*
Dealing::mutable_ciphertexts() {
  // @@protoc_insertion_point(field_mutable_list:protobuff_ser.Dealing.ciphertexts)
  return &_impl_.ciphertexts_;
}
inline const ::protobuff_ser::QFI& Dealing::_internal_ciphertexts(int index) const {
  return _impl_.ciphertexts_.Get(index);
}
inline const ::protobuff_ser::QFI& Dealing::ciphertexts(int index) const {
  // @@protoc_insertion_point(field_get:protobuff_ser.Dealing.ciphertexts)
  return _internal_ciphertexts(index);
}
inline ::protobuff_ser::QFI* Dealing::_internal_add_ciphertexts() {
  return _impl_.ciphertexts_.Add();
}
inline ::protobuff_ser::QFI* Dealing::add_ciphertexts() {
  ::protobuff_ser::QFI* _add = _internal_add_ciphertexts();
  // @@protoc_insertion_point(field_add:protobuff_ser.Dealing.ciphertexts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::QFI >&
Dealing::ciphertexts() const {
  // @@protoc_insertion_point(field_list:protobuff_ser.Dealing.ciphertexts)
  return _impl_.ciphertexts_;
}

// .protobuff_ser.QFI g_r = 2;
inline bool Dealing::_internal_has_g_r() const {
  return this != internal_default_instance() && _impl_.g_r_ != nullptr;
}
inline bool Dealing::has_g_r() const {
  return _internal_has_g_r();
}
inline void Dealing::clear_g_r() {
  if (GetArenaForAllocation() == nullptr && _impl_.g_r_ != nullptr) {
    delete _impl_.g_r_;
  }
  _impl_.g_r_ = nullptr;
}
inline const ::protobuff_ser::QFI& Dealing::_internal_g_r() const {
  const ::protobuff_ser::QFI* p = _impl_.g_r_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuff_ser::QFI&>(
      ::protobuff_ser::_QFI_default_instance_);
}
inline const ::protobuff_ser::QFI& Dealing::g_r() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.Dealing.g_r)
  return _internal_g_r();
}
inline void Dealing::unsafe_arena_set_allocated_g_r(
    ::protobuff_ser::QFI* g_r) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.g_r_);
  }
  _impl_.g_r_ = g_r;
  if (g_r) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuff_ser.Dealing.g_r)
}
inline ::protobuff_ser::QFI* Dealing::release_g_r() {
  
  ::protobuff_ser::QFI* temp = _impl_.g_r_;
  _impl_.g_r_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protobuff_ser::QFI* Dealing::unsafe_arena_release_g_r() {
  // @@protoc_insertion_point(field_release:protobuff_ser.Dealing.g_r)
  
  ::protobuff_ser::QFI* temp = _impl_.g_r_;
  _impl_.g_r_ = nullptr;
  return temp;
}
inline ::protobuff_ser::QFI* Dealing::_internal_mutable_g_r() {
  
  if (_impl_.g_r_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuff_ser::QFI>(GetArenaForAllocation());
    _impl_.g_r_ = p;
  }
  return _impl_.g_r_;
}
inline ::protobuff_ser::QFI* Dealing::mutable_g_r() {
  ::protobuff_ser::QFI* _msg = _internal_mutable_g_r();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.Dealing.g_r)
  return _msg;
}
inline void Dealing::set_allocated_g_r(::protobuff_ser::QFI* g_r) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.g_r_;
  }
  if (g_r) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(g_r);
    if (message_arena != submessage_arena) {
      g_r = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, g_r, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.g_r_ = g_r;
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.Dealing.g_r)
}

// repeated .protobuff_ser.ECP public_coefficients = 3;
inline int Dealing::_internal_public_coefficients_size() const {
  return _impl_.public_coefficients_.size();
}
inline int Dealing::public_coefficients_size() const {
  return _internal_public_coefficients_size();
}
inline void Dealing::clear_public_coefficients() {
  _impl_.public_coefficients_.Clear();
}
inline ::protobuff_ser::ECP* Dealing::mutable_public_coefficients(int index) {
  // @@protoc_insertion_point(field_mutable:protobuff_ser.Dealing.public_coefficients)
  return _impl_.public_coefficients_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::ECP >*
Dealing::mutable_public_coefficients() {
  // @@protoc_insertion_point(field_mutable_list:protobuff_ser.Dealing.public_coefficients)
  return &_impl_.public_coefficients_;
}
inline const ::protobuff_ser::ECP& Dealing::_internal_public_coefficients(int index) const {
  return _impl_.public_coefficients_.Get(index);
}
inline const ::protobuff_ser::ECP& Dealing::public_coefficients(int index) const {
  // @@protoc_insertion_point(field_get:protobuff_ser.Dealing.public_coefficients)
  return _internal_public_coefficients(index);
}
inline ::protobuff_ser::ECP* Dealing::_internal_add_public_coefficients() {
  return _impl_.public_coefficients_.Add();
}
inline ::protobuff_ser::ECP* Dealing::add_public_coefficients() {
  ::protobuff_ser::ECP* _add = _internal_add_public_coefficients();
  // @@protoc_insertion_point(field_add:protobuff_ser.Dealing.public_coefficients)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::protobuff_ser::ECP >&
Dealing::public_coefficients() const {
  // @@protoc_insertion_point(field_list:protobuff_ser.Dealing.public_coefficients)
  return _impl_.public_coefficients_;
}

// .protobuff_ser.NIZK nizk_share = 4;
inline bool Dealing::_internal_has_nizk_share() const {
  return this != internal_default_instance() && _impl_.nizk_share_ != nullptr;
}
inline bool Dealing::has_nizk_share() const {
  return _internal_has_nizk_share();
}
inline void Dealing::clear_nizk_share() {
  if (GetArenaForAllocation() == nullptr && _impl_.nizk_share_ != nullptr) {
    delete _impl_.nizk_share_;
  }
  _impl_.nizk_share_ = nullptr;
}
inline const ::protobuff_ser::NIZK& Dealing::_internal_nizk_share() const {
  const ::protobuff_ser::NIZK* p = _impl_.nizk_share_;
  return p != nullptr ? *p : reinterpret_cast<const ::protobuff_ser::NIZK&>(
      ::protobuff_ser::_NIZK_default_instance_);
}
inline const ::protobuff_ser::NIZK& Dealing::nizk_share() const {
  // @@protoc_insertion_point(field_get:protobuff_ser.Dealing.nizk_share)
  return _internal_nizk_share();
}
inline void Dealing::unsafe_arena_set_allocated_nizk_share(
    ::protobuff_ser::NIZK* nizk_share) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.nizk_share_);
  }
  _impl_.nizk_share_ = nizk_share;
  if (nizk_share) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:protobuff_ser.Dealing.nizk_share)
}
inline ::protobuff_ser::NIZK* Dealing::release_nizk_share() {
  
  ::protobuff_ser::NIZK* temp = _impl_.nizk_share_;
  _impl_.nizk_share_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::protobuff_ser::NIZK* Dealing::unsafe_arena_release_nizk_share() {
  // @@protoc_insertion_point(field_release:protobuff_ser.Dealing.nizk_share)
  
  ::protobuff_ser::NIZK* temp = _impl_.nizk_share_;
  _impl_.nizk_share_ = nullptr;
  return temp;
}
inline ::protobuff_ser::NIZK* Dealing::_internal_mutable_nizk_share() {
  
  if (_impl_.nizk_share_ == nullptr) {
    auto* p = CreateMaybeMessage<::protobuff_ser::NIZK>(GetArenaForAllocation());
    _impl_.nizk_share_ = p;
  }
  return _impl_.nizk_share_;
}
inline ::protobuff_ser::NIZK* Dealing::mutable_nizk_share() {
  ::protobuff_ser::NIZK* _msg = _internal_mutable_nizk_share();
  // @@protoc_insertion_point(field_mutable:protobuff_ser.Dealing.nizk_share)
  return _msg;
}
inline void Dealing::set_allocated_nizk_share(::protobuff_ser::NIZK* nizk_share) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.nizk_share_;
  }
  if (nizk_share) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(nizk_share);
    if (message_arena != submessage_arena) {
      nizk_share = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, nizk_share, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.nizk_share_ = nizk_share;
  // @@protoc_insertion_point(field_set_allocated:protobuff_ser.Dealing.nizk_share)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuff_ser

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dealing_2eproto
